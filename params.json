{"name":"Nerve","tagline":"An asynchronous javascript micro framework for event broadcasts along routes and channels.","body":"nerve\r\n=====\r\n\r\nAn asynchronous javascript micro framework for event broadcasts along routes and channels. This approach is similar to backbone but uses routes and channels instead of a simple token. Typically channels and routes are found in message queues in enterprise environments. This pattern is useful when you are using an MVC pattern and need separate view models to be able to talk to each other, but need to keep them loosely coupled.\r\n\r\nThe reason for creating this was to keep channels and routes logically different, rather than creating a complex token that has a single context.\r\n\r\n\r\nListening to channels and routes\r\n---\r\nWhen specifying a listener you must specify a channel and callback. Optionally you have the ability to declare a route to give greater specificity to your event subscription. Finally there is an argument that allows you to change the scope of the subscription function. Changing the scope allows us to access properties that may exist outside of our callback scope.\r\n\r\nWhen you declare a channel and/or route to listen on, if the route does not exist, one is created for you. If the channel/route does exist, then it will simple append the listener to the collection.\r\n\r\nThis pattern is similar to backbone but is smart enough to not rebind the same callback more than once if it's in the same scope. \r\n\r\n**Listening to any message on a channel**\r\n```\r\nnerve.on('order', function(context) {\r\n\r\n});\r\n```\r\n\r\n\r\n**Listening to a specific route on a channel**\r\n```\r\nnerve.on('order', 'created', function(context) {\r\n\r\n});\r\n```\r\n\r\n\r\n**Listening to a channel or route but using a different scope upon event consumption**\r\n```\r\nthis.outsideScopeProperty = 'you can see me';\r\n\r\nvar that = this;\r\n\r\nnerve.on('order', 'created', function(context) {\r\n  // The scope of the callback function has changed to whatever the subscription was told\r\n  return this.outsideScopeProperty === 'you can see me';\r\n}, that);\r\n```\r\n\r\n\r\nRemoving listeners from a channel or route\r\n---\r\nRemoving the listener will remove any callbacks that are bound to the channel or route. Notice in the examples you do not need to specify the callback function to remove it. Also you can not only remove a listener from a specific route but you can also remove all listeners from a channel.\r\n\r\n**Removing a listener for a channel**\r\n```\r\nnerve.off('order');\r\n```\r\n\r\n**Removing a listener from a specific channel's route**\r\n```\r\nnerve.off('order', 'created');\r\n```\r\n\r\n\r\n**Removing a listener from a specific channel's route that has a different scope**\r\n```\r\nvar that = this;\r\n\r\nnerve.off('order', 'created', that);\r\n```\r\n\r\nSending message along a channel or route\r\n---\r\nSending a message along a channel or route is as simple as calling send. This will asynchronously call all callbacks for channel or a channel/route combination.\r\n\r\n**Sending a message to all listeners on a channel**\r\n```\r\nnerve.send('order', {SomeProperty: 'Hello'});\r\n```\r\n\r\n**Sending a message to listeners on a channel's route**\r\n```\r\nnerve.send('order', 'created', {SomeProperty: 'Hello'});\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}